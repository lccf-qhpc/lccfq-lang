"""
Filename: xeb_util.py
Author: Santiago Nunez-Corrales
Date: 2025-08-01
Version: 1.0
Description:
    This file provides an auxiliary implementation of a classical simulator for XEB fidelity
    using random circuit sampling.

License: Apache 2.0
Contact: nunezco2@illinois.edu
"""
import numpy as np
from lccfq_lang.arch.instruction import Instruction


class XEBSimulator:
    """A barebones simulator for XEB that produces probabilities based on a
    random circuit sampling. We note this is not scalable for large qubit counts.
    """

    def __init__(self):
        pass

    @staticmethod
    def _apply_virtual_sqg(state, gate: np.ndarray, target: int, n_qubits: int):
        """Simulated single-qubit gate.

        :param state: vector state
        :param gate: numpy gate
        :param target: target qubit
        :param n_qubits: number of qubits
        :return: resulting state
        """
        I = np.eye(2)
        op = 1
        for i in reversed(range(n_qubits)):
            op = np.kron(op, gate if i == target else I)
        return op @ state

    @staticmethod
    def _apply_virtual_cx(state, control: int, target: int, n_qubits: int):
        """ Simulated CX gate

        :param state: vector state
        :param control: control qubit index
        :param target: target qubit index
        :param n_qubits: number of qubits
        :return: resulting state
        """
        dim = 2 ** n_qubits
        new_state = np.copy(state)

        for i in range(dim):
            b = format(i, f"0{n_qubits}b")
            if b[n_qubits - 1 - control] == '1':
                flipped = list(b)
                tbit = n_qubits - 1 - target
                flipped[tbit] = '0' if b[tbit] == '1' else '1'
                j = int("".join(flipped), 2)
                new_state[j] += state[i]
                new_state[i] = 0
            else:
                new_state[i] += state[i]

        return new_state

    def _apply_virtual_instruction(self, state, instr: Instruction, n_qubits: int):
        """Simulate an arbitrary instruction.

        :param state: vector state
        :param instr: instruction
        :param n_qubits: number of qubits
        :return: resulting state
        """
        gate_numeric = {
            "h": (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]]),
            "x": np.array([[0, 1], [1, 0]]),
            "y": np.array([[0, -1j], [1j, 0]]),
            "z": np.array([[1, 0], [0, -1]]),
            "s": np.array([[1, 0], [0, 1j]]),
            "t": np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]])
        }

        if instr.symbol in gate_numeric:
            gate = gate_numeric[instr.symbol]
            return self._apply_virtual_sqg(state, gate, instr.target_qubits[0], n_qubits)

        elif instr.symbol == "cx":
            return self._apply_virtual_cx(state, instr.control_qubits[0], instr.target_qubits[0], n_qubits)

        else:
            return state

    def probabilities(self, circuit, n_qubits):
        """Estimate probabilities from ideal realization.

        :param circuit: circuit to simulate
        :param n_qubits: number of qubits
        :return: probabilities generated by the circuit
        """
        dim = 2 ** n_qubits
        state = np.zeros(dim, dtype=complex)
        state[0] = 1.0  # |000...0âŸ©

        for instr in circuit:
            state = self._apply_virtual_instruction(state, instr, n_qubits)

        probs = np.abs(state) ** 2
        bitstrings = [format(i, f"0{n_qubits}b") for i in range(dim)]
        return dict(zip(bitstrings, probs))